先简单记一下各种标志位的设置方法。
ZF。最简单的，只要判断运算结果所有位都为零即可，方法是将结果的所有二进制位全部用OR gate进行或运算，得到的结果就是ZF的值。
OF。这个是用来判断是否发生无符号数溢出(最高位前一位是否进位)的，直接把第n-1位的进位输出到OF上就可以。
CF。这个是用来判断无符号数是否发生溢出的，较为复杂一点，方法是把s与运算结果最高位的进位异或输出到CF上，其中s的值在运算为加法时被设为0，在运算为减法的时候被设为1
SF，判断有符号数是否为负数，方法是直接检测最高一个二进制位。


经常让我困惑的是CF和OF两个条件码是怎么回事。我想谈谈自己对它们的理解。
在功能上，CF主要用于检查无符号数是否发生溢出，而OF则用于检查有符号数是否溢出。
尽管计算机在实际运算的时候都使用补码编码，并不区分有符号数和无符号数，但我们实际使用的时候会区别对待这两种数字，所以需要用两个不同的条件码来处理无符号数和有符号数的溢出情况。
那么，CPU是怎样检查一个运算是否在无符号数或者有符号数的意义上发生了溢出呢，先让我们看看运算的时候发生了什么。
问题的关键在于理解什么是溢出。直观简单地说，运算发生溢出的时候，产生了意料之外的运算结果。这是因为，计算机中的数字（在大多数程序中通常是这样，比如用C语言编写的程序）是使用一个固定字长的数据块来保存一个数字。
有限的空间让数字的无限扩张是不可能的。因此计算机进行的数学运算和普通的运算并不相同，计算机实行模数加法，而不是普通的加法。固定长度的二进制位所能表示的数字是一个有限集合，显然计算机进行的运算对这个集合是封闭的。
我们只要记住，当计算机的模数加法和普通的加法得出不一样的结果时，就发生了溢出。这里我们不考虑减法，因为减法实际上是被转化成加法来运算的，我们也不考虑浮点数，只考虑整数。

判断有符号数溢出很简单。最高位在这里被解释称符号，而这个最高位在一般情况下不会由于进位而变为1
    当一个正数加上一个绝对值更大的负数时，最高位的1是直接从负数那里被拷贝过来的
    当一个负数

